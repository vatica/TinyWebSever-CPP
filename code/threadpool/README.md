# 半同步/半反应堆线程池

## 五种I/O模型
+ 同步I/O：内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作
   + 阻塞I/O：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作
   + 非阻塞I/O：非阻塞等待，每隔一段时间就去检测I/O事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain
   + 信号驱动I/O：linux用套接口进行信号驱动I/O，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件
   + I/O复用：linux用select/poll函数实现I/O复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作、写操作的I/O函数进行检测。知道有数据可读或可写时，才真正调用I/O操作函数
+ 异步I/O：linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序

## 事件处理模式

+ reactor模式：主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元)，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I/O实现
+ proactor模式：主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由异步I/O实现

## 同步I/O模拟proactor模式

异步I/O不成熟，实际使用较少。

1. 主线程往epoll内核事件表注册socket上的读就绪事件
2. 主线程调用epoll_wait等待socket上有数据可读
3. 当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列
4. 睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
5. 主线程调用epoll_wait等待socket可写
6. 当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果

## 两种高效的并发编程模式

半同步/半异步：同步线程用于处理客户逻辑，异步线程用于处理I/O事件。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中，请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象

+ 半同步/半反应堆
   1. 主线程充当异步线程，负责监听所有socket上的事件
   2. 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
   3. 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
   4. 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权
   
   + 缺点：1）线程获取任务时需要对请求队列加锁，耗费cpu时间。2）一个工作线程在同一时间只能处理一个客户请求，在客户请求数量多的情况下变慢，若增加工作线程，则线程切换也会耗费时间。

领导者/追随者模式

## 线程池

空间换时间，浪费服务器的硬件资源，换取运行效率