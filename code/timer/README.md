# 定时器

## 基础知识

+ 非活跃，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。

+ 定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。

+ 定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。

+ 定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。

+ Linux下三种定时方法：1）socket选项SO_RECVTIMEO和SO_SNDTIMEO。2）SIGALRM信号。3）I/O复用系统调用的超时参数

## 主要流程

利用alarm函数周期性地触发SIGALRM信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。

+ 信号通知流程：进程收到信号时，操作系统中断进程进入信号处理函数。为避免信号竞态现象，信号处理函数中不会再次被信号打断，为防止信号被屏蔽过久，需要信号处理函数尽可能快地执行操作。对于处理逻辑复杂的情况，解决方案是信号处理函数仅发送信号通知程序主循环，由主循环执行对应的逻辑代码。

+ 统一事件源：将信号事件与其他事件一样被处理。信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用I/O复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过epoll来监测，从而实现统一处理。

+ 信号处理机制
  + 信号的接收：接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。

  + 信号的检测：进程陷入内核态后，有两种场景会对信号进行检测。1）进程从内核态返回用户态前。2）进程在内核态中，从睡眠状态被唤醒时。

  + 信号的处理：1）信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。2）接下来进程返回到用户态中，执行相应的信号处理函数。3）信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。

## 定时器的使用

+ 浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到链表上

+ 处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器

+ 处理定时信号时，将定时标志设置为true

+ 处理读事件时，若某连接上发生读事件，将对应定时器向后移动，否则，执行定时事件

+ 处理写事件时，若服务器通过某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件